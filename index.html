<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hand Cricket Prototype (Gestures 1-6)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
      color: #fff;
    }

    #hud {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 16px;
      background: rgba(0,0,0,0.4);
      border-radius: 8px;
      font-size: 16px;
      line-height: 1.4;
      color: #fff;
      text-align: center;
      min-width: 260px;
      border: 1px solid rgba(255,255,255,0.15);
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
      user-select: none;
      pointer-events: none;
    }

    #errorBox {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255,0,0,0.15);
      border: 1px solid rgba(255,0,0,0.5);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.4;
      color: #ff8080;
      max-width: 360px;
      white-space: pre-line;
      user-select: text;
      display: none;
    }

    #titleText {
      position: absolute;
      top: 60px;
      width: 100%;
      text-align: center;
      font-size: 20px;
      font-weight: 500;
      letter-spacing: 0.03em;
      color: white;
      text-shadow: 0 2px 8px rgba(0,0,0,0.7);
      user-select: none;
      pointer-events: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
  </style>
</head>
<body>
  <div id="hud">Loadingâ€¦</div>
  <div id="titleText">Hand Cricket Prototype</div>
  <div id="errorBox"></div>

  <!-- Local Three.js (must sit next to this HTML file) -->
  <script src="three.js"></script>

  <script>
    try {
      /**********************************
       * BASIC THREE SETUP
       **********************************/
      const scene = new THREE.Scene();
      // background: deep teal / navy style
      scene.background = new THREE.Color(0x0f2228);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 5, 8);
      camera.lookAt(0, 1.5, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      /**********************************
       * LIGHTS
       **********************************/
      const ambient = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
      keyLight.position.set(-3, 6, 4);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.width = 1024;
      keyLight.shadow.mapSize.height = 1024;
      keyLight.shadow.camera.near = 0.5;
      keyLight.shadow.camera.far = 20;
      keyLight.shadow.camera.left = -5;
      keyLight.shadow.camera.right = 5;
      keyLight.shadow.camera.top = 5;
      keyLight.shadow.camera.bottom = -5;
      scene.add(keyLight);

      /**********************************
       * TABLE + GROUND
       **********************************/
      const tableMat = new THREE.MeshStandardMaterial({
        color: 0x5a4a1f, // brown/olive
        roughness: 0.7,
        metalness: 0.0
      });

      const tableTopGeo = new THREE.BoxGeometry(6, 0.4, 4);
      const tableTop = new THREE.Mesh(tableTopGeo, tableMat);
      tableTop.position.set(0, 1.5, 0);
      tableTop.receiveShadow = true;
      scene.add(tableTop);

      function makeLeg(x, z) {
        const legGeo = new THREE.BoxGeometry(0.4, 2.0, 0.4);
        const leg = new THREE.Mesh(legGeo, tableMat);
        leg.position.set(x, 0.5, z);
        leg.castShadow = true;
        leg.receiveShadow = true;
        scene.add(leg);
      }
      makeLeg( 2.5,  1.5);
      makeLeg(-2.5,  1.5);
      makeLeg( 2.5, -1.5);
      makeLeg(-2.5, -1.5);

      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x0a0a0a,
        roughness: 1.0,
        metalness: 0.0
      });
      const groundGeo = new THREE.PlaneGeometry(20, 20);
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);

      // slight rotation to mimic your reference angle
      tableTop.rotation.y = 0.15;

      /**********************************
       * HAND BUILDERS
       * We'll build hands from blocks so we can "fold" fingers.
       **********************************/

      // Helper to make a palm-like block
      function makeBlock(w, h, d, colorHex) {
        const geo = new THREE.BoxGeometry(w, h, d);
        const mat = new THREE.MeshStandardMaterial({
          color: colorHex,
          roughness: 0.6,
          metalness: 0.0
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        return mesh;
      }

      // Helper to make a "finger"
      function makeFinger(len, thick, colorHex) {
        const geo = new THREE.BoxGeometry(len, thick, thick);
        const mat = new THREE.MeshStandardMaterial({
          color: colorHex,
          roughness: 0.6,
          metalness: 0.0
        });
        const m = new THREE.Mesh(geo, mat);
        m.castShadow = true;
        m.receiveShadow = true;
        return m;
      }

      /**********************************
       * LEFT HAND = PLAYER HAND
       * color: green-ish
       * We'll give it 5 extendable fingers + 1 thumb.
       **********************************/
      const playerHand = new THREE.Group();
      scene.add(playerHand);

      const PLAYER_COLOR = 0x5b8050;

      // palm
      const playerPalm = makeBlock(2.2, 0.5, 1.2, PLAYER_COLOR);
      playerPalm.position.set(0, 0, 0);
      playerHand.add(playerPalm);

      // fingers array (index, middle, ring, pinky)
      const playerFingers = [];
      const fingerSpacing = 0.35; // Z offset between fingers
      for (let i = 0; i < 4; i++) {
        const f = makeFinger(1.4, 0.25, PLAYER_COLOR);
        f.position.set(1.2, 0.15, (i - 1.5) * fingerSpacing);
        playerHand.add(f);
        playerFingers.push(f);
      }

      // thumb
      const playerThumb = makeFinger(0.8, 0.3, PLAYER_COLOR);
      playerThumb.position.set(0.8, -0.05, -0.8);
      playerThumb.rotation.y = -0.5;
      playerHand.add(playerThumb);

      // initial pose / position on table
      playerHand.rotation.x = -0.3;
      playerHand.rotation.y = 0.35;
      playerHand.position.set(-1.5, 1.8, -0.5);

      /**********************************
       * RIGHT HAND = OPPONENT HAND
       * color: skin-ish
       * We'll ALSO give it extendable fingers.
       **********************************/
      const enemyHand = new THREE.Group();
      scene.add(enemyHand);

      const ENEMY_COLOR = 0xd9a477;

      // "palm" block (thicker like a fist base)
      const enemyPalm = makeBlock(2.0, 1.0, 1.4, ENEMY_COLOR);
      enemyPalm.position.set(0, 0, 0);
      enemyHand.add(enemyPalm);

      // enemy fingers
      const enemyFingers = [];
      const enemyFingerSpacing = 0.4;
      for (let i = 0; i < 4; i++) {
        const knuckle = makeBlock(1.0, 0.5, 0.5, ENEMY_COLOR);
        // Roughly where knuckles would show
        knuckle.position.set(1.0, 0.3 - (i*0.02), (i - 1.5) * enemyFingerSpacing);
        enemyHand.add(knuckle);
        enemyFingers.push(knuckle);
      }

      // enemy thumb block
      const enemyThumb = makeBlock(0.8, 0.5, 0.5, ENEMY_COLOR);
      enemyThumb.position.set(-0.6, -0.2, 0.8);
      enemyThumb.rotation.z = 0.4;
      enemyHand.add(enemyThumb);

      // enemy wrist-ish block
      const enemyWrist = makeBlock(0.8, 0.8, 1.0, ENEMY_COLOR);
      enemyWrist.position.set(-1.2, -0.2, 0);
      enemyWrist.rotation.z = 0.2;
      enemyHand.add(enemyWrist);

      // place on table
      enemyHand.rotation.x = -0.2;
      enemyHand.rotation.y = -0.6;
      enemyHand.position.set(1.5, 1.9, 0.5);

      // small extra angle so it matches your concept feel
      playerHand.rotation.y += 0.15;
      enemyHand.rotation.y -= 0.1;

      /**********************************
       * GESTURE LOGIC (1-6)
       *
       * We'll simulate:
       * 1 -> only index finger extended
       * 2 -> index+middle
       * 3 -> index+middle+ring
       * 4 -> all 4 long fingers
       * 5 -> all 4 long fingers + thumb
       * 6 -> same as 5 (for cricket, 6 is max run; we'll just treat like full open)
       *
       * "Extended" = scale normal size
       * "Folded"   = scaled small, pulled back
       **********************************/

      function setHandNumber(handType, num) {
        // handType: "player" or "enemy"
        // num: 1..6
        const isPlayer = (handType === "player");

        const fingersArr = isPlayer ? playerFingers : enemyFingers;
        const thumbObj   = isPlayer ? playerThumb   : enemyThumb;

        // how many long fingers to extend?
        // mapping: 1->1,2->2,3->3,4->4,5->4,6->4 (thumb handled separately)
        let longFingersToShow;
        if (num <= 4) {
          longFingersToShow = num;
        } else {
          longFingersToShow = 4;
        }

        // thumb visible for 5 or 6, hidden otherwise
        const thumbVisible = (num >= 5);

        // Apply transforms to each long finger
        for (let i = 0; i < fingersArr.length; i++) {
          const f = fingersArr[i];
          if (i < longFingersToShow) {
            // extended
            f.scale.set(1, 1, 1);
            f.position.y = isPlayer ? 0.15 : (0.3 - (i*0.02));
            f.position.x = isPlayer ? 1.2  : 1.0;
          } else {
            // folded
            f.scale.set(0.3, 0.3, 0.3);
            // tuck closer to palm
            f.position.y = isPlayer ? 0.05 : 0.1;
            f.position.x = isPlayer ? 0.4  : 0.3;
          }
        }

        // thumb transform
        if (thumbObj) {
          if (thumbVisible) {
            // show thumb = scaled normal
            thumbObj.scale.set(1,1,1);
            if (isPlayer) {
              thumbObj.position.set(0.8, -0.05, -0.8);
              thumbObj.rotation.set(0, -0.5, 0);
            } else {
              thumbObj.position.set(-0.6, -0.2, 0.8);
              thumbObj.rotation.set(0,0,0.4);
            }
          } else {
            // hide thumb = fold down
            thumbObj.scale.set(0.2,0.2,0.2);
            if (isPlayer) {
              thumbObj.position.set(0.3, -0.1, -0.4);
              thumbObj.rotation.set(0, 0, 0);
            } else {
              thumbObj.position.set(-0.4, -0.4, 0.2);
              thumbObj.rotation.set(0,0,0);
            }
          }
        }
      }

      /**********************************
       * "ROLL" NEW NUMBERS EVERY 2s
       **********************************/
      let lastRollTime = performance.now();
      let playerValue = 0;
      let enemyValue = 0;

      const hudEl = document.getElementById("hud");
      function rollHandsIfTime(nowMs) {
        if (nowMs - lastRollTime > 2000) {
          lastRollTime = nowMs;

          // random 1-6
          playerValue = 1 + Math.floor(Math.random() * 6);
          enemyValue  = 1 + Math.floor(Math.random() * 6);

          // update poses
          setHandNumber("player", playerValue);
          setHandNumber("enemy",  enemyValue);
        }

        hudEl.innerText =
          "You: " + playerValue +
          "   |   Opponent: " + enemyValue +
          "\n(Hands auto-roll every 2s)";
      }

      // initialize first pose
      playerValue = 1;
      enemyValue = 1;
      setHandNumber("player", playerValue);
      setHandNumber("enemy",  enemyValue);

      /**********************************
       * IDLE MOTION
       **********************************/
      function idleAnimation(t) {
        // gentle breathing bob
        playerHand.position.y = 1.8 + Math.sin(t * 1.5) * 0.02;
        enemyHand.position.y  = 1.9 + Math.sin(t * 1.5 + 1.2) * 0.02;
      }

      /**********************************
       * MAIN LOOP
       **********************************/
      function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        const t = now * 0.001;

        idleAnimation(t);
        rollHandsIfTime(now);

        renderer.render(scene, camera);
      }
      animate();

      /**********************************
       * RESIZE HANDLER
       **********************************/
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

    } catch (err) {
      const errorBox = document.getElementById('errorBox');
      errorBox.style.display = 'block';
      errorBox.textContent =
        "ERROR (JS crashed):\n" + err.message + "\n" + err.stack;
      console.error(err);
    }
  </script>
</body>
</html>
